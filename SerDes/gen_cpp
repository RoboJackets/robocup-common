#!/usr/bin/python
# -*- coding: utf-8 -*-
#kate: indent-mode python ; space-indent true ; indent-width 4

import sys
from xml.dom.minidom import *

class Struct:
    def __init__(self, parent, name):
        # Struct containing this one
        self.parent = parent
        
        # Name of this struct type
        self.name = name
        
        # The full name of the external class for this struct or
        # None if this is not an external struct
        self.externalName = None
        
        # True if there are no members in this struct
        self.empty = True
        
        # Map of typenames to child structs
        self.structs = {}
        
        # Map of typenames enums defined in this struct (but not in children)
        self.enums = {}
        
        # Map from typename to type object for all structs and enums
        # directly in this struct which are external.
        self.externals = {}

class Enum:
    def __init__(self, parent, name, storageType, defaultValue = None):
        # Struct containing this Enum type
        self.parent = parent

        # Name of this enum type
        self.name = name
        
        # The full name of the external type for this enum or
        # None if this is not an external struct
        self.externalName = None
        
        # Name of the type used to store data of this enum type
        self.storageType = storageType
        
        # Value to which a member of this type is initialized if it isn't declared with a value
        self.defaultValue = defaultValue

########################

primitives = ['bool', 'float', 'double']

typeMap = {'string': 'std::string'}

# Add int* and uint* to primitives and typeMap
for i in ['8', '16', '32', '64']:
    typename = 'int' + i
    typeMap[typename] = typename + '_t'
    typeMap['u' + typename] = 'u' + typename + '_t'
    primitives.append(typename)
    primitives.append('u' + typename)

indentLevel = 0
indentString = ''

def indent():
    global indentLevel
    indentLevel += 1
def unindent():
    global indentLevel
    indentLevel -= 1
def write(str = ''):
    print ' ' * (indentLevel * 4) + str

# Converts a typename in a given scope to an external typename.
# If typename does not name an external type, the name is returned unchanged
def mapExternalType(scope, typename):
    while scope != None:
        if typename in scope.externals:
            return scope.externals[typename].externalName
        scope = scope.parent
    return typename

def cType(scope, typename):
    if typename in typeMap:
        return typeMap[typename]
    return mapExternalType(scope, typename)

# Returns the full C++ type name for a struct defined at a given DOM node
def fullName(scope, node):
    ext = node.getAttribute('external_cpp')
    if ext != '':
        return ext
    
    name = node.getAttribute('typename')
    
    parent = node.parentNode
    while parent != None and parent.nodeType == parent.ELEMENT_NODE:
        name = parent.getAttribute('typename') + '::' + name
        parent = parent.parentNode
    return cType(scope, 'Packet::' + name)

# Returns the type used to store a member of a given type (primitive or enum)
def storageTypeInScope(scope, typename):
    # Primitives are always in scope
    if typename in primitives:
        return typename
    
    while scope != None:
        if typename in scope.enums:
            return scope.enums[typename].storageType
        scope = scope.parent
    
    return None

# Returns the default value for a type in a given scope.
def defaultValueInScope(scope, typename):
    # Primitives are always in scope
    if typename in primitives:
        return '0'
    
    while scope != None:
        if typename in scope.enums:
            return scope.enums[typename].defaultValue
        scope = scope.parent
    
    return None

def emitEnumConstant(node, enum, lastValue):
    name = node.getAttribute('name')
    assert(name != '')
    
    value = node.getAttribute('value')
    if value == '':
        value = lastValue + 1
    else:
        value = int(value)
    
    storageType = node.getAttribute('type')
    assert(storageType == '' or storageType == enum.storageType)
    
    line = '%s = %d' % (name, value)
    
    return (value, line)

def emitEnum(node, parentStruct):
    typename = node.getAttribute('typename')
    assert(typename != '')
    
    storageType = node.getAttribute('type')
    assert(storageType != '')
    assert(storageType in primitives)
    
    defaultValue = node.getAttribute('default')
    if defaultValue == '':
        # Find the first value
        for child in node.childNodes:
            if child.nodeType == Node.ELEMENT_NODE:
                defaultValue = child.getAttribute('name')
                break
    
    enum = Enum(parentStruct, typename, storageType, defaultValue)
    parentStruct.enums[typename] = enum
    
    external = node.getAttribute('external_cpp')
    if external != '':
        # Don't emit a declaration for this enum
        enum.externalName = external
        parentStruct.externals[typename] = enum
        return
    
    if parentStruct.externalName:
        # Don't emit code for an enum in an external struct
        return
        
    write('enum %s' % typename)
    write('{')
    indent()
    
    # Parse items
    lastValue = -1
    line = None
    for child in node.childNodes:
        if child.nodeType == Node.ELEMENT_NODE:
            assert(child.nodeName == 'constant')
            
            # Put a comma on the previous line and write it out
            if line != None:
                write(line + ',')
            
            (lastValue, line) = emitEnumConstant(child, enum, lastValue)
    
    # Each line is delayed so we can add a comma if there is another item
    if line != None:
        write(line)
        
    unindent()
    write('};')
    write()

def emitConstant(node, parentStruct):
    name = node.getAttribute('name')
    assert(name != '')
    
    storageType = node.getAttribute('type')
    assert(storageType != '')
    
    value = node.getAttribute('value')
    assert(value != '')
    
    write('static const %s %s = %s;' % (cType(parentStruct, storageType), name, value))

def emitMember(node, parentStruct):
    typename = node.getAttribute('type')
    assert(typename != '')
    
    name = node.getAttribute('name')
    assert(name != '')
    
    write('%s %s;' % (cType(parentStruct, typename), name))

def emitArray(node, parentStruct):
    typename = node.getAttribute('type')
    assert(typename != '')
    
    name = node.getAttribute('name')
    assert(name != '')
    
    size = node.getAttribute('size')
    if size == '':
        # Variable size
        write('std::vector<%s> %s;' % (cType(parentStruct, typename), name))
    else:
        # Fixed size
        assert(node.getAttribute('sizetype') == '')
        write('%s %s[%s];' % (cType(parentStruct, typename), name, size))

def emitMemberCtor(node, parentStruct):
    # Error checking has already been done in emitMember
    name = node.getAttribute('name')
    value = node.getAttribute('value')
    
    typename = node.getAttribute('type')
    if storageTypeInScope(parentStruct, typename) == None:
        # If this type isn't stored with a primitive type, it will be automatically initialized
        assert(value == '')
        return
    
    if value == '':
        value = defaultValueInScope(parentStruct, typename)
        
    write('%s = %s;' % (name, value))

def emitArrayCtor(node, parentStruct):
    # Error checking has already been done in emitArray
    name = node.getAttribute('name')
    typename = node.getAttribute('type')
    value = node.getAttribute('value')
    
    if storageTypeInScope(parentStruct, typename) == None:
        # If this type isn't stored with a primitive type, it will be automatically initialized
        assert(value == '')
        return
    
    if value == '':
        value = defaultValueInScope(parentStruct, typename)
    
    size = node.getAttribute('size')
    if size != '':
        write('for (int i = 0; i < %s; ++i)' % size)
        write('{')
        indent()
        write('%s[i] = %s;' % (name, value))
        unindent()
        write('}')

def emitStruct(node, parentStruct):
    typename = node.getAttribute('typename')
    assert(typename != '')
    thisStruct = Struct(parentStruct, typename)
    
    if parentStruct != None:
        parentStruct.structs[typename] = thisStruct
    
    # Determine if the struct is empty even if it's external
    for child in node.childNodes:
        if child.nodeType == Node.ELEMENT_NODE:
            if child.nodeName == 'member' or child.nodeName == 'array':
                thisStruct.empty = False
                break
    
    external = node.getAttribute('external_cpp')
    if external != '':
        # Don't emit any declarations for this struct
        thisStruct.externalName = external
        if parentStruct != None:
            parentStruct.externals[typename] = thisStruct
        
        # Parse type declarations to get storage types (needed for serialization body)
        for child in node.childNodes:
            if child.nodeType == Node.ELEMENT_NODE:
                if child.nodeName == 'enum':
                    emitEnum(child, thisStruct)
                elif child.nodeName == 'struct':
                    emitStruct(child, thisStruct)
        
        return thisStruct
    
    extend = node.getAttribute('extend_cpp')
    
    write('class %s' % typename)
    
    if extend != '':
        write (' : public %s' % extend)
    
    write('{')
    indent()
    write('public:')
    indent()
    
    # Declarations
    for child in node.childNodes:
        if child.nodeType == Node.ELEMENT_NODE:
            if child.nodeName == 'struct':
                emitStruct(child, thisStruct)
            elif child.nodeName == 'enum':
                emitEnum(child, thisStruct)
            elif child.nodeName == 'constant':
                emitConstant(child, thisStruct)
            elif child.nodeName == 'member':
                emitMember(child, thisStruct)
            elif child.nodeName == 'array':
                emitArray(child, thisStruct)
    
    # Constructor
    write()
    write('%s()' % typename)
    write('{')
    indent()
    for child in node.childNodes:
        if child.nodeType == Node.ELEMENT_NODE:
            if child.nodeName == 'member':
                emitMemberCtor(child, thisStruct)
            elif child.nodeName == 'array':
                emitArrayCtor(child, thisStruct)
    unindent()
    write('}')
    
    unindent()
    unindent()
    write('};')
    write()
    
    return thisStruct

def emitMemberSerialization(child, thisStruct):
    name = child.getAttribute('name')
    typename = child.getAttribute('type')
    
    storageType = storageTypeInScope(thisStruct, typename)
    if storageType == None:
        write('buf & obj.%s;' % name)
    else:
        write('buf.template memberCast<%s>(obj.%s);' % (cType(thisStruct, storageType), name))

def emitArraySerialization(child, thisStruct):
    name = child.getAttribute('name')
    typename = child.getAttribute('type')
    storageType = storageTypeInScope(thisStruct, typename)
    
    size = child.getAttribute('size')
    if size == '':
        # Variable size array
        sizetype = child.getAttribute('sizetype')
        if sizetype == '':
            sizetype = 'uint32'
        
        if storageType == None:
            write('buf.template arrayVariable<%s>(obj.%s);' % (cType(thisStruct, sizetype), name))
        else:
            write('buf.template arrayVariableCast<%s, %s>(obj.%s);' % (cType(thisStruct, sizetype), cType(thisStruct, storageType), name))
    else:
        # Fixed size array
        if storageType == None:
            write('buf.arrayFixed(obj.%s);' % (name))
        else:
            write('buf.template arrayFixedCast<%s>(obj.%s);' % (cType(thisStruct, storageType), name))

def emitStructSerialization(node, thisStruct):
    name = fullName(thisStruct, node)
    
    if thisStruct.empty == True and thisStruct.externalName != None:
        # Emit no body for empty external structs (assuming it will be defined in another file)
        return
    
    for child in node.childNodes:
        if child.nodeType == Node.ELEMENT_NODE:
            if child.nodeName == 'struct':
                emitStructSerialization(child, thisStruct.structs[child.getAttribute('typename')])
    
    write('template<typename B>')
    write('void operator&(B &buf, ' + name + ' &obj)')
    write('{')
    indent()
    
    for child in node.childNodes:
        if child.nodeType == Node.ELEMENT_NODE:
            if child.nodeName == 'member':
                emitMemberSerialization(child, thisStruct)
            elif child.nodeName == 'array':
                emitArraySerialization(child, thisStruct)
    
    unindent()
    write('}')
    
    write()

########################

if len(sys.argv) != 2:
    sys.stderr.write('Usage: ' + sys.argv[0] + ' <input.xml>\n')
    sys.exit(1)

filename = sys.argv[1]
dom = parse(filename)
root = dom.firstChild

while root != None and (root.nodeType != Node.ELEMENT_NODE or root.nodeName != 'struct'):
    root = root.nextSibling
if root == None:
    sys.stderr.write('No root struct found\n')
    sys.exit(1)

# Declarations
write('#pragma once')
write()
write('#include <vector>')
write('#include <Serialization.hpp>')
write('#include <string>')
write()

# Include headers for external types
have_includes = False
def emitIncludes(node):
    global have_includes
    inc = node.getAttribute('include_cpp')
    if inc != '':
        have_includes = True
        if inc.startswith('.'):
            write('#include "' + inc + '"')
        else:
            write('#include <' + inc + '>')
    for child in node.childNodes:
        if child.nodeType == Node.ELEMENT_NODE:
            emitIncludes(child)

emitIncludes(root)
if have_includes:
    write()

# Declarations
write('namespace Packet')
write('{')
indent()

rootStruct = emitStruct(root, None)

unindent()
write('}')
write()

# Serialization bodies
emitStructSerialization(root, rootStruct)
